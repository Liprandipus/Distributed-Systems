Was asked :
to create a concurrent
server (server process) which as
service task will perform the following computations (taking as inputs
a real number a and a vector of integers of the form Y (y1,y2,...,yn) of length n
where n is defined by the user, and which can be sent iteratively
by one or more clients
/ client processes):
1. The average value of the vector Y (return: a real number)
2. The maximum and minimum value of Y (return: a table of length 2 integers)
3. The product a*Y (return: a vector of real numbers of length n)

How was "calc.x" file created :
The starting point and guiding principle of the whole project is the compilation of the .x file.
The saved approach would produce complete .c files of the client and server.
Therefore, the struct calculations is defined in this file with the following members :
array[100] → the array where the user data is stored
a → the number by which to multiply the array to the requested 3
choice → the choice of the requested
minmax[2] → a two-position array to which the min and max of the requested 2 will be returned
size → the size to be set based on the size of the table to be given
The CALC_PROG function is then defined in the program. Any statement within it,
creates a corresponding function in the client and server files. It also binds the members of the
struct defined above to these codes. Each function is consistent with each
task at hand. The definition of the first function is of float type since in the first
option, a real number is returned. The second and third functions are of type
calculations, that is, they return values to the arguments declared above as members of
struct calculations.
An important point also is that the correct definition of the functions in the .x file,
outputs ready-made client and server templates that just need filling in.

How was "calc_client.c" file created :
This file was provided as a template from the .x file.
The main and the calc_prog_1 function that communicates with the server was completed.
The main function consists of two members :
On the one hand, the first reading of the input is through the command line. That is, the arguments of
program also carry the input data.
The format that the first input from the command line should be :
hostname a choice array[1] array[2] .... array[n]
Calculating the size is easy since argc has the value of the definitions given
from the command line. The argc - 4 is derived from the program name, the hostname, the
a and the choice. Therefore, all other arguments are numbers that create both the
table.
The argv has the command line arguments in it. The argv[0] has the name of
program in general.
The host takes the value of argv[1] which carries the name of the host, a1 takes that of a with
using atof ( ASCII to float), because the program takes the data as characters.
The choice becomes atoi ( ASCII to Integer) and is placed in the variable choice1.
We malloc an array table and then place the data given by
command line, one by one. We run iteratively by the size of the potential array,
and we atof the argument i+4 because the elements of the array start at the fourth position and
then :
let the input localhost 2 3 1 2 3 ( argv[0] = program name, argv[1] = hostname , argv[2] = a ,
argv[3] = choice, argv[4] = 1 , argv[5] = 2 , argv[6] = 3 )
first iteration → argc = 4 , i = 0 , 4 + 0 = 4 so argv[4] = 1
second iteration → argc = 4, i = 1 , 4 + 1 = 5 so argv[5] = 2
third iteration → argc = 4, i = 2 , 4 + 2 = 6 so argv[6] = 3.
We then call calc_prog_1 with arguments the table, its size, a and choice.
Second, after the first import of data from the command line, the import will be done with
scanf commands. Therefore we declare an array_2[100]1 array and follow the same
procedure. Now the user has seen what he is asked to type since there are
screen messages. The user is also, after the first input of data, asked if he wants to
continue with the data entry. His choice is stored in a flag and is left
raised. Within an iterative while, the user is asked for the size of the table, a,
the selection and the table data. The calc_prog_1 function is called again.
The calc_prog_1 function on the one hand contains for each struct function from the .x file, a
array of variables that give access to the members of the struct.
The first step is to pass the values from the variables of main to the variables of
struct.
Then it checks which choice was given and prints the corresponding result value which
generated by server_calc.c
In case of an error, there is error handling code.
1. A static table was declared, not a dynamic table because if we used array_1 (pointer
to float), there would be possible memory leaks.

How was "calc_client.c" file created :
he server code contains the three functions that do the calculations of the
and a void function message which prints an update message new
connection.
Each function accesses the client data through the argp structure pointing to the
array, choice, a, etc. variables.
The first function simply returns the average value of the array.
The second function returns the max and min value. After these values are calculated,
they return to the result variable pointing to the minmax[2] variable defined in the struct named
calculations.
The third function multiplies the value of each element by the value a and returns
modified array.


How to run the code :
The way to do this is simply to run the "make" command in the directory where the above is located
files in order to produce the executable files.
In one terminal run the command ./calc_server while in another terminal window run the
./calc_client hostname a choice [1] array[2] .... array[n]

Attention!
The format of the first data entry is as follows :
./calc_client hostname a choice [1] array[2] .... array[n]
This is how main is structured to place the input in the correct variables. Otherwise, it will
we will have execution errors or even undesirable results.
